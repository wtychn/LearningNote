# 计算机操作系统

---
layout: post
title: "计算机操作系统"
date: 2021-05-22 17:37
comments: true
tags: 
	- 计算机操作系统
    - 知识总结

---

## 进程管理

### 1. 进程状态切换

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="img" style="zoom:80%;" />

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

### 2. 进程调度

#### 2.1 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

- 先来先服务 first-come first-service（FCFS）

- 短作业优先 shortest job first（SJF）

- 最短剩余时间优先 shortest remaining time next（SRTN）

#### 2.2 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

- 时间片轮转

- 优先级调度

- 多级反馈队列：时间片轮转 + 优先级调度

  <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" style="zoom:100%;" />

  每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

#### 2.3 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

### 3. 进程通信

#### 3.1 管道

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

#### 3.2 命名管道（FIFO）

也称为命名管道，去除了管道只能在父子进程中使用的限制。

#### 3.3 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

#### 3.4 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

#### 3.5 共享存储 [J]

**java 可以通过 IO 实现。**

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。

#### 3.6 套接字 [J]

**java 可以实现 socket。**

与其它通信机制不同的是，它可用于不同机器间的进程通信。

#### 远程方法调用（RMI）[J]

能够让在某个 java 虚拟机上的对象像调用本地对象一样调用另一个 java 虚拟机中的对象上的方法。

本质是使用网络进行通信。

## 内存管理

## 1. 虚拟内存

CPU 直接操作物理地址则只能运行一个程序，两个程序就会出现内存错误。

操作系统把进程所使⽤的地址「隔离」开来，即让操作系统为每个进程分配独⽴的⼀套「虚
拟地址」。操作系统引⼊了虚拟内存，进程持有的虚拟地址会通过 CPU 芯⽚中的内存管理单元
（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。

操作系统是管理虚拟地址与物理地址之间的关系有两种：

### 1.1 内存分段

程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段
是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。

通过段选择子和段内偏移量组成的虚拟地址。

存在的问题：

- 第⼀个就是内存碎⽚的问题。
- 第⼆个就是内存交换的效率低的问题。

### 1.2 内存分页

分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩。这样⼀个连续并且尺⼨固定
的内存空间，我们叫⻚（Page）。

通过页号和页内偏移量组成虚拟地址。

为了解决页表过大的问题，**多级页表**出现了。还有专⻔存放程序最常访问的⻚表项的 Cache ，TLB。

### 1.3 段页式内存管理

段⻚式内存管理实现的⽅式：

- 先将程序划分为多个有逻辑意义的段，也就是前⾯提到的分段机制；
- 接着再把每个段划分为多个⻚，也就是对分段划分出来的连续空间，再划分固定⼤⼩的
  ⻚；

虚拟地址结构就由段号、段内⻚号和⻚内位移三部分组成。

## 异步调用

### 1. selest

select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：

<img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAicgy5qFYcyoWPAV31k82icRe6I4Lya2F9qWcBlhHv3kzpgt9yjD7Hnpw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:80%;" />

可以看出几个细节：

1. select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）
2. select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）
3. select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）

可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。

### 2. poll

它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。

### 3. epoll

epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。

epoll 主要就是针对 select 三点问题进行了改进。

1. 内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。
2. 内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。
3. 内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。

<img src="https://mmbiz.qpic.cn/mmbiz_gif/GLeh42uInXTyY80RSpUTLjIMiaGGicv9zAjXNXJTV82eOqkbJdOrDpQpAaWiceBqvAXyFEOTdV5fC2dNsL29yBW7w/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="图片" style="zoom:80%;" />

