# MySQL 知识总结
---
layout: post
title: "数据库和 MySQL"
date: 2021-04-10 22:15
comments: true
tags: 
	- 数据库
	- 知识总结

---
MySQL 是一种开源的关系型数据库，也是目前 Java 开发中非常常用的关系型数据库。其默认端口号是 **3306**。

## 语句是如何在 MySQL 中执行的

```mermaid
graph LR
A(连接器)-->B(查询缓存)-->C(分析器)-->D(优化器)-->E(执行器)
```

- **连接器**：身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存**：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除）。
- **分析器**：没有命中缓存的话，SQL 语句就会经过分析器，分析器就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器**：按照 MySQL 认为最优的方案去执行。
- **执行器**：执行语句，然后从存储引擎返回数据。

## 存储引擎

MySQL 最常用的两种存储引擎是 **MyISAM** 和 **InnoDB** ，在5.7版本的所有存储引擎中只用 InnoDB是支持事务的。MyISAM 在 5.5 版本之前都是 MySQL 的默认数据库引擎，但是 5.5 版本之后 MySQL 加入了 InnoDB 引擎，并且将其设为默认引擎。这两者主要有以下区别：

|                        | MyISAM               | InnoDB             |
| ---------------------- | -------------------- | ------------------ |
| 行级锁                 | 不支持，只支持表级锁 | 支持表级锁及行级锁 |
| 事务及崩溃后的安全恢复 | 不支持，但是速度更快 | 支持               |
| 外键                   | 不支持               | 支持               |
| MVCC*                  | 不支持               | 支持               |
| 索引类型               | 非聚簇索引           | 聚簇索引           |

*MVCC：Multi-Version Concurrency Control，即多版本并发控制，就是要做到维持一个数据的多个版本，使得在不加锁的情况下读写操作没有冲突。

## 日志

### 1. redo log（InnoDB 引擎特有日志）

当有一条记录需要更新的时候：

1. InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存；
2. InnoDB 引擎会在系统比较空闲的时候，将这个操作记录更新到磁盘里面。

InnoDB 的 redo log 是固定大小的，redo log 是循环记录的。从头开始写，写到末尾就又回到开头循环写。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

### 2. binlog（MySQL Server 层日志）

|          | redo log                                     | binlog                                                       |
| -------- | -------------------------------------------- | ------------------------------------------------------------ |
| 谁来实现 | InnoDB 引擎                                  | MySQL 的 Server 层                                           |
| 记录什么 | 物理日志，记录的是在某个数据页上做了什么修改 | 逻辑日志，记录的是这个语句的原始逻辑                         |
| 会覆盖吗 | 循环写的，空间固定会用完                     | 可以追加写入。写到一定大小后会切换到下一个，并不会覆盖以前的日志 |

### 3. 两阶段提交

redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。

<img src="https://gitee.com/wtychn/ImageBed/raw/master/img/image-20210627122844510.png" style="zoom:70%;" />

两阶段提交就是让这**两个状态保持逻辑上的一致**。如果两个日志分开写，那么其中一个写完另一个没写时宕机会造成两个日志恢复的结果不一致。

假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. **先写 redo log 后写 binlog。**假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
2. **先写 binlog 后写 redo log。**如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

## 索引

索引**是一个排序的列表**，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。

### 1. B+树

MySQL 使用B+树作为存储的数据结构，B-树是一种多路自平衡搜索树，而B+树相对于B-树的特点是：

- 所有关键字存储在叶子节点出现。非叶子节点只存了索引值，只在最后一行才存放了行记录，这样极大地减小了索引大小。
- 为所有叶子结点增加了一个链指针。加强了区间访问性，可使用范围区间查找。

<img src="https://gitee.com/wtychn/ImageBed/raw/master/img/image-20210315171145768.png" alt="image-20210315171145768" style="zoom:67%;" />

### 2. 聚簇索引与非聚簇索引

<img src="https://gitee.com/wtychn/ImageBed/raw/master/img/image-20210316154002490.png" alt="image-20210316154002490" style="zoom: 43%;" />

#### 2.1 聚簇索引（主键）

- 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。

- 聚簇索引就是按照每张表的主键构造一颗B+树，**叶子节点中存放的是包含主键在内的整条行记录数据。**这个特性决定了表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。

- 如果使用聚簇索引，则通过其他辅助索引进行搜索时，辅助索引B+树叶子节点存放的是主键值，再通过主键值的聚簇索引B+树找到数据行。

- 聚簇索引会改变表中行的物理顺序，数据行按照一定的顺序排列，并且自动维护这个顺序。

#### 2.2 非聚簇索引（辅助索引）

在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。**辅助索引叶子节点存储的不再是行的物理位置，而是主键值。**通过辅助索引首先找到的是主键值，再通过主键值找到数据行。

#### 2.3 聚簇索引的优势

- 由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了缓存中，再次访问时，会在内存中完成访问，不必访问磁盘。

- 辅助索引的叶子节点，存储主键值，而不是数据的存放地址。因此当行数据发生变化时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了；另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

- 因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。

不过，如果涉及到大数据量的排序、全表扫描、计数之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

#### 2.4 聚簇索引主键使用自增id

聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，它会不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

### 3. 联合索引

经过辅助索引查询列名时需要先通过辅助索引查到主键索引，再通过主键索引查到该列，其中**回到主键索引树搜索的过程，我们称为回表**。通过在辅助索引和需要查询的列之间建立联合索引可以减少回表，提高查询效率。

#### 3.1 最左前缀原则

不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

#### 3.2 索引下推

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

- 无索引下推时需要先回表查出所有符合最左索引条件的记录再对比剩余条件；
- 有索引下推时在查询中直接对比联合索引中的每个条件，不满足索引的直接过滤掉，不需要回表再对比。

### 6. explain

<img src="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png" alt="img" style="zoom:80%;" />

1、**id**：这是SELECT的查询序列号

2、**select_type**：

```
SIMPLE：简单 SELECT(不使用 UNION 或子查询等)
PRIMARY：最外面的 SELECT
UNION：UNION 中的第二个或后面的 SELECT 语句
DEPENDENT UNION：UNION 中的第二个或后面的 SELECT 语句，取决于外面的查询
UNION RESULT：UNION 的结果。
SUBQUERY：子查询中的第一个 SELECT
DEPENDENT SUBQUERY：子查询中的第一个 SELECT，取决于外面的查询
DERIVED：导出表的 SELECT(FROM 子句的子查询)
```

3、**table**：显示这一行的数据是关于哪张表的

4、**type**：这列最重要，显示了连接使用了哪种类别，有无使用索引，是使用 explain 命令分析性能瓶颈的关键项之一。

```
- ALL：Full Table Scan，MySQL 将遍历全表以找到匹配的行
- index: Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树
- range:只检索给定范围的行，使用一个索引来选择行
- ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
- eq_ref: 类似 ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件
- const、system: 当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量，system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system
- NULL: MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
```

结果值从好到坏依次是：

```
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
```

一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。

5、**possible_keys**：列指出 MySQL 能使用哪个索引在该表中找到行

6、**key**：显示MySQL实际决定使用的键（索引），如果没有选择索引，键是NULL

7、**key_len**：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好

8、**ref**：显示使用哪个列或常数与key一起从表中选择行。

9、**rows**：显示 MySQL 认为它执行查询时必须检查的行数。

10、**Extra**：包含 MySQL 解决查询的详细信息，也是关键参考项之一。

```
- Distinct：一旦 MYSQL 找到了与行相联合匹配的行，就不再搜索了；
- Not exists：MYSQL 优化了 LEFT JOIN，一旦它找到了匹配 LEFT JOIN 标准的行，就不再搜索了；
- Range checked for each Record（index map:#）：没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一；
- Using filesort：看到这个的时候，查询就需要优化了。MYSQL 需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行；
- Using index：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候；
- Using temporary：看到这个的时候，查询需要优化了。这里，MYSQL 需要创建一个临时表来存储结果，这通常发生在对不同的列集进行 ORDER BY 上，而不是 GROUP BY 上；
- Using where：使用了 WHERE 从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型 ALL 或 index，这就会发生，或者是查询有问题。
```

### 5. 不使用索引的情况

1. 如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如，如果列 key 均匀分布在 1 和 100 之间，下面的查询使用索引就不是很好：

   ```sql
   select * from table_name where key>1 and key<90
   ```

2. 用 or 分隔开的条件，如果 or 前的条件中的列有索引，而后面的列没有索引，那么涉及到的索引都不会被用到，例如：

   ```sql
   select * from table_name where key1='a' or key2='b'
   ```

   如果在 key1 上有索引而在 key2 上没有索引，则该查询也不会走索引；

3. 复合索引，如果索引列不是复合索引的第一部分，则不使用索引（即不符合最左前缀），例如，复合索引为 (key1, key2)，则以下查询将不会使用索引：

   ```sql
   select * from table_name where key2='b'
   ```

4. 如果 like 是以 ‘%’ 开始的，则该列上的索引不会被使用。例如：

   ```sql
   select * from table_name where key1 like '%a'
   ```

   该查询即使 key1 上存在索引，也不会被使用；

5. 如果列为字符串，则 where 条件中必须将字符常量值加引号，否则即使该列上存在索引，也不会被使用。例如 ,

   ```sql
   select * from table_name where key1=1
   ```

   如果 key1 列保存的是字符串，即使 key1 上有索引，也不会被使用；

6. WHERE 字句的查询条件里有不等于号（WHERE column!=...）, 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描；
7. where 子句中对字段进行 null 值判断 where mobile = null 此查询 不会走索引
8. in 和 not in 也要慎用，否则会导致全表扫描；
9. 在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运算，系统将可能无法正确使用索引。

## 事务

事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。

### 1. 事务的四大特性

一般来说，事务是必须满足4个条件（**ACID**）：

#### 1.1 原子性（Atomicity）

一个事务中的所有操作是不可被再分割的最小执行单位，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

#### 1.2 一致性（Consistency）

在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的
预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。(比如：A向B
转账，不可能A扣了钱，B却没有收到）

#### 1.3 隔离性（Isolation）

数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由
于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括**读未提交**（Read uncommitted）、**读**
**提交**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。（比如：A正
在从一张银行卡里面取钱，在A取钱的过程中，B不能向这张银行卡打钱）

#### 1.4 持久性（Durability）

事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 2. 事务的实现原理

mysql 每条记录在更新的时候都会同时记录一条回滚操作 undolog，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

<img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="img" style="zoom:50%;" />

在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

当系统里没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除。

#### 2.1 MVCC 的实现

MVCC 的实现依赖于 每行的隐藏字段，`DB_TRX_ID`，`DB_ROLL_PTR`，删除标记位，还有 read_view。

##### 2.1.1 三个隐藏字段

innoDB 向数据库中存储的每行添加三个隐藏字段。

###### 1）`DB_TRX_ID` 事务 id

占 6 字节，表示这一行数据最后插入或修改的事务 id。此外删除在内部也被当作一次更新，在行的特殊位置添加一个删除标记（记录头信息有一个字节存储是否删除的标记）。

###### 2）`DB_ROLL_PTR` 回滚指针

占 7 字节，回滚指针指向被写在`Rollback segment`中的 undo log 记录，在该行数据被更新的时候，undo log 会记录该行修改前内容到 undo log。

###### 3）`DB_ROW_ID` 行 ID

占 7 字节，他就项自增主键一样随着插入新数据自增。如果表中不存主键 或者 唯一索引，那么数据库 就会采用`DB_ROW_ID`生成聚簇索引。否则`DB_ROW_ID`不会出现在索引中。

##### 2.1.2 undo log

undo log 是为回滚而用，具体内容就是 copy 事务前的数据库内容（行）到 undo buffer，在适合的时间把 undo buffer 中的内容刷新到磁盘。undo buffer 与 redo buffer 一样，也是环形缓冲，但当缓冲满的时候，undo buffer 中的内容会也会被刷新到磁盘；与 redo log 不同的是，磁盘上不存在单独的 undo log 文件，所有的 undo log 均存放在主 ibd 数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。

undo log 在 `Rollback segment`中又被细分为 insert 和 update undo log ，insert 类型的 undo log 仅仅用于事务回滚 , 当事务一旦提交，insert undo log 就会被丢弃。

update 的 undo log 被用于 一致性的读和事务回滚，update undo log 的清理是在没有事务需要对这部分数据快照进行一致性读的时候进行清理。

每次对数据进行更新操作时，都会 copy 当前数据，保存到 undo log 中。并修改当前行的回滚指针指向 undo log 中的旧数据行。

<img src="https://pic2.zhimg.com/80/v2-7bf5161cec5a0fddc22887b68a135349_1440w.jpg" alt="img" style="zoom:50%;" />

##### 2.1.3 read-view

InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，**当前正在“活跃”的所有事务 ID**。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

<img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" alt="img" style="zoom:40%;" />

这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

3. 如果落在黄色部分，那就包括两种情况:

   a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；

   b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

### 3. 隔离性

#### 3.1 隔离性的四个隔离级别与并发问题

- 读未提交（read uncommitted）
- 读已提交（read committed）
- 可重复读（repeatable read）
- 串行化（serializable）

|            | 读未提交 | 读已提交 | 可重复读 | 串行化  |
| ---------- | -------- | -------- | -------- | ------- |
| 脏读       | ***√***  | &times;  | &times;  | &times; |
| 不可重复读 | &radic;  | &radic;  | &times;  | &times; |
| 幻读       | &radic;  | &radic;  | &radic;  | &times; |

#### 3.2 读未提交

- 事物A和事物B，事物A未提交的数据，事物B可以读取到
- 这里B读取到的数据叫做“脏数据”，叫**脏读**（Dirty read）
- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别

#### 3.3 读已提交

- 能读到别的事物已经提交的数据
- A事务在本次事务中，有其他事务提交了，所以A对自己操作过的数据，进行了多次读取发现数据不一致，即**不可重复读**（Unrepeatable read）

#### 3.4 可重复读

- 事务未结束时多次查询到的值不会发生变化，即事务在执行期间看到的数据前后必须是一致的。
- A事务在本次事务中对未操作的数据进行多次查询，发现第一次没有，第二次出现了，就像幻觉一样。或者第一次有而第二次没有，即**幻读**（Phantom read）。
- 针对`delete`和`insert`。

#### 3.5 串行化

- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免幻读，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发。
- 别的地方一用这个数据就不能修改删除，直到别的地方提交

这里需要注意的是:与 SQL 标准不同的地方在于 InnoDB 存储引擎在可重读（repeatable read）事务隔离级别下使用的是 Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统（如 SQL Server）是不同的。所以说 InnoDB存储引擎的默认支持的隔离级别是可重读（repeatable read）已经可以完全保证事务的隔离性要求，即达到了SQL标准的串行化（serializable）隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是读已提交（read committed），但是你要知道的是 **InnoDB 存储引擎默认使用可重读（repeatable read）并不会有任何性能损失**。

## 锁

数据库锁机制简单来说，就是数据库为了保证数据的一致性，使各种共享资源在被访问时变得有序而设计的一种规则。MySQL 的锁机制比较简单最著的特点是不同的存储引擎支持不同的锁机制。 **InnoDB 支持行锁，(有时也会升级为表锁）MyISAM 只支持表锁**。

- **表锁**的特点就是开销小、加锁快，不会出现死锁。锁粒度大，发生锁冲突的概率小，并发度相对低。
- **行锁**的特点就是开销大、加锁慢，会出现死锁。锁粒度小，发生锁冲突的概率高，并发度高。

### 1. InnoDB 间隙锁

- **记录锁**（Record Lock）：记录锁加在索引上，是标准的单个行记录的行级锁
- **间隙锁**（Gap Lock）：锁定范围，不包含记录本身
- **Next-Key Lock**：记录锁 + 间隙锁，当InnoDB扫描索引时会先对索引加上记录锁，再对索引两边加上间隙锁。能够锁定一个范围，包含记录本身。

InnoDB 对于行查询使用 Next-Key Lock ，其中**间隙锁能够解决幻读问题**，因为单记录锁只能够锁住当前行，但是不能防止新增和删除其他行。

### 2. InnoDB 插入意向锁（Insert Intention Lock）

插入意图锁是在行插入之前通过INSERT操作设置的一种特殊间隙锁。
注意：多个事务插入同一个间隙的不同位置，他们并不会冲突。 假设存在索引记录，其值分别为4和7。单独的事务分别尝试插入值5和6，在获得插入行的排他锁之前，每个事务都使用插入意图锁来锁定4和7之间的间隙， 但他们不会互相阻塞。

## 大表优化

当 MySQL 单表数据过多时，数据库 CRUD 性能明显下降，以下是一些常见的优化措施：

### 1. 限定数据范围

禁止不带任何限制范围的查询语句。比如：在查询历史订单时，限制在一个月范围内。

### 2. 读写分离

主从分离，主库读，从库写。

### 3. 垂直拆分

将数据表列进行拆分，把一张列较多的表拆分为多张表。

- **优点**：使得每一条行数据变小，在查询时减小读取硬盘块的个数，减少I/O次数。同时还能够简化表结构，使其变得易于维护。
- **缺点**：主键变得冗余，并且会引起`join`操作，可以通过应用层的联结来解决。并且垂直拆分还会让事务变得复杂。

### 4. 水平拆分

保持表结构不变，但是将表存储的数据分片，存放到不同的表或库中，达到分布式的目的。

分表只能够解决单一表过大的问题，但是表还是存储在同一台机器上，所以对于并发能力提升并没有什么意义，所以**水平分表最好分库**。

常见分片方案：

- 客户端代理：分片逻辑在应用端，封装在 jar 包里，通过修改或封装 JDBC 层实现。
- 中间件代理：在应用和数据中间加代理层。分片逻辑统一维护在中间件服务中。

> 引用：
>
> 1. [JavaGuide](https://gitee.com/SnailClimb/JavaGuide)面试突击版
> 2. [IT楠老师](https://www.itnanls.cn/)笔记

