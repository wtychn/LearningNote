# Redis 相关知识总结

最常使用的非关系型数据库，由于在内存中运行，速度很快，所以常作为缓存使用。

<img src="https://gitee.com/wtychn/ImageBed/raw/master/img/image-20210523203155794.png" alt="image-20210523203155794" style="zoom: 67%;" />

## 1. 数据结构

Redis 的键值对采用**哈希表**的形式存储。

## 2. 单线程模型

Redis 虽然是单线程模型，但是采用了**多路复用机制**来保证其在网络 IO 操作中能够并发处理大量客户端请求，实现高吞吐率。

<img src="https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg" alt="img" style="zoom: 15%;" />

大体流程是这样的：

1. Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。该机制允许内核中，**同时存在多个监听套接字和已连接套接字**。图中的 FD 就是刚才所说的多个套接字。
2. select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个**事件队列**，Redis 单线程对该事件队列不断进行处理。
3. Redis 采用 Socket 网络模型，该模型本身支持非阻塞模式。比如当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以**返回处理其他操作**，而不用一直等待。

## 3. 日志与快照

Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。

### 3.1 AOF 日志

AOF 日志是写后日志，即先执行命令再把数据写入内存。

AOF 里记录的是 Redis 收到的每一条命令，这些命令是以**文本形式** (file) 保存的。" * + 数字 " 在开头，表示命令有几个部分；" $ + 数字 "表示这部分命令、键或值一共有多少字节。比如`set testkey testvalue`这条命令的日志为：

```
*3	// 表示命令有3个部分
$3	// 表示这部分有3个字节
set
$7	// 表示这部分有7个字节
testkey
$9	// 表示这部分有9个字节
testvalue
```

因为是写后日志，所以 Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。

AOF 的潜在风险：

1. 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。

2. AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。

相应的写会策略：

|  配置项  |     写回时机     | 数据丢失                 | 性能                             |
| :------: | :--------------: | ------------------------ | -------------------------------- |
|  Always  |     同步写会     | 可靠性高，数据基本不丢失 | 每个写命令都要落盘，性能影响较大 |
| Everysec |     每秒写回     | 宕机时丢失1秒数据        | 性能适中                         |
|    No    | 操作系统控制写回 | 宕机时丢失数据较多       | 性能好                           |

AOF 日志过大时对文件进行重写，将命令进行多合一。日志重写过程不会阻塞，由后台子进程 bgrewriteaof 来完成。过程为“一个拷贝，两处日志”：

- “一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。
- “两处日志”指的是，有新来操作时这个操作会被同时写到正在使用的日志缓冲和重写日志缓冲中。这样，重写日志也不会丢失最新的操作。

<img src="https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg" alt="img" style="zoom:15%;" />

### 3.2 RDB 快照

和 AOF 相比，RDB 记录的是某一时刻的数据而不是操作，所以在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

- **save**：在主线程中执行，会导致阻塞；
- **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

为了解决快照时写操作的问题，Redis 借助操作系统提供的写时复制技术（COW），主线程修改时修改的是创建的键值副本，而快照则是将原键值写入 RDB 快照。

<img src="https://static001.geekbang.org/resource/image/a2/58/a2e5a3571e200cb771ed8a1cd14d5558.jpg" alt="img" style="zoom: 5%;" />

Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

## 4. 高可靠性

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

<img src="https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg" alt="img" style="zoom:20%;" />

### 4.1 主从同步

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系。

第一次同步的流程

<img src="https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="img" style="zoom:20%;" />

从库数量太多会导致主库忙于生成 RDB 文件，阻塞主线程和占用带宽。可以采用 “主 - 从 - 从” 模式，通过从库级联将压力分散到从库上。

其中 repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置 master_repl_offset，从库则会记录自己已经读到的位置 slave_repl_offset。正常情况下，这两个偏移量基本相等。

<img src="https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg" alt="img" style="zoom:18%;" />

在网络断连阶段，主库如果收到新的写操作命令，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。

### 4.2  哨兵机制

哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。

- 监控：哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。
- 选主：主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。
- 通知：把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。

#### 4.2.1 哨兵集群

哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，**误判率也能降低**。

哨兵集群判断主库是否下线的判断原则是：少数服从多数。

筛选条件：

1. 优先级 slave-priority；
2. 和旧主库同步程度最接近的从库得分高，slave_repl_offset 需要最接近 master_repl_offset；
3. ID 号小的从库得分高。

#### 4.2.2 pub/sub 机制

哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。

<img src="https://static001.geekbang.org/resource/image/ca/b1/ca42698128aa4c8a374efbc575ea22b1.jpg" alt="img" style="zoom:20%;" />

##### 哨兵与哨兵

除了哨兵实例，我们自己编写的应用程序也可以通过 Redis 进行消息的发布和订阅。为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。**只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换**。

##### 哨兵与从库

由哨兵向主库发送 INFO 命令来完成的。哨兵给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。

##### 哨兵与客户端

每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。

#### 4.2.3 哪个哨兵执行主从切换？

也是同样的投票制。

想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。

### 4.3 切片集群

切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。

#### 4.3.1 Redis Cluster

Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。一个切片集群共有 16384 个哈希槽。

具体的映射过程分为两大步：首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

#### 4.3.2 客户端定位数据

1. Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。
2. 客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。
3. Redis 重新分配哈希槽。
4. 当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址（重定向）。
5. 如果请求数据还在迁移中，那么旧实例返回 ASK 命令，指明新的所在槽和新实例地址。
6. 客户端需要向新实例发送 ASKING 命令让这个实例允许执行客户端接下来发送的命令，然后客户端再向这个实例发送 GET 命令，以读取数据。

<img src="https://static001.geekbang.org/resource/image/e9/b0/e93ae7f4edf30724d58bf68yy714eeb0.jpg" alt="img" style="zoom:20%;" />

